'''
    Adapted from course 16831 (Statistical Techniques).
    Initially written by Paloma Sodhi (psodhi@cs.cmu.edu), 2018
    Updated by Wei Dong (weidong@andrew.cmu.edu), 2021
'''

import numpy as np
import math
import time
from matplotlib import pyplot as plt
from scipy.stats import norm

from map_reader import MapReader


class SensorModel:
    """
    References: Thrun, Sebastian, Wolfram Burgard, and Dieter Fox. Probabilistic robotics. MIT press, 2005.
    [Chapter 6.3]
    """
    def __init__(self, occupancy_map):
        """
        TODO : Tune Sensor Model parameters here
        The original numbers are for reference but HAVE TO be tuned.
        """
        self._z_hit = 150 #150
        self._z_short = 18 #17.5
        self._z_max = 15 #15
        self._z_rand = 100

        '''z_sum = self._z_hit + self._z_short + self._z_max + self._z_rand
        self._z_hit = self._z_hit / z_sum
        self._z_short = self._z_short / z_sum
        self._z_max = self._z_max / z_sum
        self._z_rand = self._z_rand / z_sum'''

        self._sigma_hit = 100 # originally 50
        self._lambda_short = 15 # Originally 0.1

        # Used in p_max and p_rand, optionally in ray casting
        self._max_range = 1000

        # Used for thresholding obstacles of the occupancy map
        self._min_probability = 0.35

        # Used in sampling angles in ray casting
        self._subsampling = 1
        #print(occupancy_map[:4])

    def beam_range_finder_model(self, z_t1_arr, x_t1, occupancy_map):
        """
        param[in] z_t1_arr : laser range readings [array of 180 values] at time t
        param[in] x_t1 : particle state belief [x, y, theta] at time t [world_frame]
        param[out] prob_zt1 : likelihood of a range scan zt1 at time t
        """
        """
        TODO : Add your code here
        """

        # Ray casting
        x_start = x_t1[0]
        y_start = x_t1[1]
        theta_robot = x_t1[2]
        x_start += 25 * np.cos(theta_robot)
        y_start += 25 * np.sin(theta_robot)
        theta_robot = theta_robot - (np.pi/2)
        x_start = x_start//10
        y_start = y_start//10
        #x_new = x_start
        #y_new = y_start
        q = 0
        total_probs = []
        #map_obj = MapReader('data/map/wean.dat')
        #occupancy_map = map_obj.get_map()
        #src_path_map = 'data/map/wean.dat'
        #map1 = MapReader(src_path_map)
        #map1.visualize_map()
        ray_casting_measurements = []
        '''coord_list_X = []
        coord_list_Y = []'''
        for i in range(0, 180, self._subsampling):
            x_new = x_start
            y_new = y_start
            prob_finding_obj = 0
            #print(prob_finding_obj)
            j = 0.8
            while (prob_finding_obj < self._min_probability):
                x_new += j * np.cos(theta_robot + ((i)*np.pi)/180)
                y_new += j * np.sin(theta_robot + ((i)*np.pi)/180)
                #print(x_new)
                x_new_pass = int(x_new)

                y_new_pass = int(y_new)
               
                if 0 < x_new_pass < 800 and 0 < y_new_pass < 800:
                    prob_finding_obj = occupancy_map[y_new_pass][x_new_pass]
                    #print(prob_finding_obj)
                    #j += 0.1
                else:
                    x_new_pass = x_start
                    y_new_pass = y_start
                    prob_finding_obj = 0.8
            if x_new_pass != x_start:
                actual_dist = np.sqrt((x_new_pass*10 - x_start*10)**2 + (y_new_pass*10 - y_start*10)**2)
            else:
                actual_dist = 1
            '''print("Found wall")'''
            '''coord_list_X.append(x_new_pass)
            coord_list_Y.append(y_new_pass)'''

            #x_new = x_start
            #y_new = y_start

            '''if actual_dist == 1:
                prob_log = np.log(1)
                #total_probs.append(prob_log)
                q += prob_log''' #akshay commented this out
            
            if x_new_pass != x_start:
                # Compute probabilities
                # 1. Measurement noise (Narrow Gausian)
                #print(z_t1_arr[i])
                if z_t1_arr[i]>=0 and z_t1_arr[i]<=self._max_range:
                    #print("I'm here")
                    p_hit = np.exp(-1 / 2 * (z_t1_arr[i] - actual_dist) ** 2 / (self._sigma_hit ** 2))
                    p_hit = p_hit / (np.sqrt(2 * np.pi * self._sigma_hit ** 2))
                    #print(actual_dist)
                    #print(p_hit)
                else:
                    p_hit = 0
                # 2. Unexpected objects (Exponential)
                if z_t1_arr[i]>=0 and z_t1_arr[i]<=actual_dist:
                    p_short = self._lambda_short * np.exp(-1 * self._lambda_short * z_t1_arr[i])
                    #print(p_short)
                else:
                    p_short = 0
                # 3. Sensor failure (Max range measurement)
                if z_t1_arr[i] <= self._max_range:
                    p_max = 1
                else:
                    p_max = 0
                # 4. Random measurements (Unexplainable measurements)
                if z_t1_arr[i]>=0 and z_t1_arr[i]<self._max_range:
                    p_rand = (1/self._max_range)
                else:
                    p_rand = 0
                # Computing the probabilities
                prob = (self._z_hit * p_hit) + (self._z_short * p_short) + (self._z_max * p_max) + (self._z_rand * p_rand)
                #print(p_hit)
                #total_probs.append(prob)
                if prob != 0:
                    prob_log = np.log(prob)
                    #total_probs.append(prob_log)
                    q = np.sum(q + prob_log)
            


            #ray_casting_measurements.append(actual_dist)
        #print(ray_casting_measurements)

        '''plt.figure(figsize=(5,5), dpi=120)
        plt.plot(ray_casting_measurements, total_probs)
        plt.xlabel('Measurements')
        plt.ylabel('Probabilities')
        plt.show()
        plt.pause(10)'''
        
        #print(q)
        '''fig = plt.figure()
        mng = plt.get_current_fig_manager()
        plt.ion()
        plt.imshow(occupancy_map, cmap='Greys')
        plt.axis([0, 800, 0, 800])
        print(coord_list_X)
        print(coord_list_Y)
        plt.scatter(coord_list_X, coord_list_Y)
        plt.show()
        plt.pause(100)'''
        q = np.exp(q)
        return q
        
        #prob_zt1 = 1.0
        #return prob_zt1
    
    

#if __name__=="__main__":
    '''
    map_obj = MapReader('data/map/wean.dat')
    occupancy_map = map_obj.get_map()
    sensor1 = SensorModel(occupancy_map)
    #x = sensor1.ray_cast(x_t1=[4892, 916, 0.523599])
   # [143.09999999999965, 143.19998478015023, 143.29992394784608, 143.3997871878255, 143.49954427102986, 143.59916506336248, 143.69861953434466, 143.7978777656694, 143.8969099596472, 143.99568644754964, 144.0941776978428, 144.19235432431222, 144.2901870940812, 144.38764693551548, 144.48470494601986, 144.58133239972096, 144.67750075504034, 144.77318166215252, 144.86834697033152, 144.96296873518318, 145.05701922576444, 145.15047093158773, 145.24329656951326, 145.3354690905239, 145.42696168638975, 145.51774779621587, 145.6078011128778, 145.69709558934173, 145.78560544487263, 145.87330517112753, 145.96016953813756, 146.0461736001756, 146.13129270151322, 146.21550248206418, 146.29877888291824, 146.38109815176247, 146.4624368481944, 146.54277184892155, 146.62208035285718, 146.70033988610285, 146.77752830682533, 146.85362381002545, 146.92860493220087, 147.00245055590338, 147.07513991418895, 147.14665259496562, 147.21696854523722, 147.2860680752429, 147.35393186249587, 147.4205409557191, 147.48587677868278, 147.5499211339386, 147.6126562064584, 147.6740645671705, 147.73412917640312, 147.79283338722536, 147.85016094869783, 147.9060960090237, 147.96062311860572, 148.01372723301225, 148.0653937158463, 148.11560834152476, 148.1643572979658, 148.21162718918333, 148.25740503779295, 148.30167828742808, 148.34443480506565, 148.38566288326624, 148.4253512423237, 148.46348903232845, 148.50006583514508, 148.53507166630342, 148.56849697680516, 148.60033265484344, 148.63057002743955, 148.65920086199685, 148.68621736776953, 148.71161219724868, 148.73537844746642, 148.75750966121873, 148.7779998282043, 148.7968433860846, 148.81403522146027, 148.82957067077066, 148.84344552110818, 148.85565601095695, 148.86619883084782, 148.8750711239372, 148.88227048650282, 148.88779496836383, 148.89164307321875, 148.89381375890594, 148.89430643758453, 148.8931209758359, 148.89025769468768, 148.88571736955717, 148.87950123011814, 148.87161096008512, 148.86204869692307, 148.8508170314739, 148.83791900750583, 148.82335812118333, 148.8071383204572, 148.78926400437453, 148.7697400223088, 148.74857167311086, 148.72576470417727, 148.7013253104393, 148.6752601332715, 148.64757625931682, 148.61828121923074, 148.58738298634398, 148.55488997524134, 148.52081104025785, 148.4851554738918, 148.4479330051337, 148.40915379770948, 148.3688284482398, 241.68486219744236, 241.76690514828766, 241.84795179172522, 241.92797845376347, 242.00696178135323, 242.0848787482812, 242.16170666095752, 242.2374231640953, 242.3120062462808, 242.38543424544, 242.4576858541925, 242.528740125098, 242.598576475798, 242.66717469404142, 242.73451494260777, 242.8005777641172, 242.86534408573425, 242.92879522375762, 242.99091288810467, 243.05167918668593, 243.1110766296677, 243.16908813362656, 243.22569702559343, 243.2808870469891, 243.33464235744924, 243.3869475385389, 243.43778759736006, 243.48714797004627, 243.53501452514953, 243.58137356691998, 243.62621183846994, 243.66951652483468, 243.71127525592078, 243.75147610934607, 243.79010761317204, 243.827158748523, 243.86261895209924, 243.89647811858404, 243.9287266029343, 243.95935522257054, 243.98835525945367, 244.0157184620534, 244.0414370472101, 244.06550370188742, 244.087911584816, 244.10865432803112, 244.12772603829856, 244.14512129843592, 244.16083516852575, 244.1748631870164, 244.18720137172255, 244.19784622071015, 244.20679471308003, 244.21404430963898, 244.21959295346625, 244.2234390703717, 244.22558156924575, 244.22601984230246, 244.22475376521348, 244.22178369713774, 244.21711048063958, 244.21073544150136]
    x = sensor1.beam_range_finder_model([143.09999999999965, 143.19998478015023, 143.29992394784608, 143.3997871878255, 143.49954427102986, 143.59916506336248, 143.69861953434466, 143.7978777656694, 143.8969099596472, 143.99568644754964, 144.0941776978428, 144.19235432431222, 144.2901870940812, 144.38764693551548, 144.48470494601986, 144.58133239972096, 144.67750075504034, 144.77318166215252, 144.86834697033152, 144.96296873518318, 145.05701922576444, 145.15047093158773, 145.24329656951326, 145.3354690905239, 145.42696168638975, 145.51774779621587, 145.6078011128778, 145.69709558934173, 145.78560544487263, 145.87330517112753, 145.96016953813756, 146.0461736001756, 146.13129270151322, 146.21550248206418, 146.29877888291824, 146.38109815176247, 146.4624368481944, 146.54277184892155, 146.62208035285718, 146.70033988610285, 146.77752830682533, 146.85362381002545, 146.92860493220087, 147.00245055590338, 147.07513991418895, 147.14665259496562, 147.21696854523722, 147.2860680752429, 147.35393186249587, 147.4205409557191, 147.48587677868278, 147.5499211339386, 147.6126562064584, 147.6740645671705, 147.73412917640312, 147.79283338722536, 147.85016094869783, 147.9060960090237, 147.96062311860572, 148.01372723301225, 148.0653937158463, 148.11560834152476, 148.1643572979658, 148.21162718918333, 148.25740503779295, 148.30167828742808, 148.34443480506565, 148.38566288326624, 148.4253512423237, 148.46348903232845, 148.50006583514508, 148.53507166630342, 148.56849697680516, 148.60033265484344, 148.63057002743955, 148.65920086199685, 148.68621736776953, 148.71161219724868, 148.73537844746642, 148.75750966121873, 148.7779998282043, 148.7968433860846, 148.81403522146027, 148.82957067077066, 148.84344552110818, 148.85565601095695, 148.86619883084782, 148.8750711239372, 148.88227048650282, 148.88779496836383, 148.89164307321875, 148.89381375890594, 148.89430643758453, 148.8931209758359, 148.89025769468768, 148.88571736955717, 148.87950123011814, 148.87161096008512, 148.86204869692307, 148.8508170314739, 148.83791900750583, 148.82335812118333, 148.8071383204572, 148.78926400437453, 148.7697400223088, 148.74857167311086, 148.72576470417727, 148.7013253104393, 148.6752601332715, 148.64757625931682, 148.61828121923074, 148.58738298634398, 148.55488997524134, 148.52081104025785, 148.4851554738918, 148.4479330051337, 148.40915379770948, 148.3688284482398, 241.68486219744236, 241.76690514828766, 241.84795179172522, 241.92797845376347, 242.00696178135323, 242.0848787482812, 242.16170666095752, 242.2374231640953, 242.3120062462808, 242.38543424544, 242.4576858541925, 242.528740125098, 242.598576475798, 242.66717469404142, 242.73451494260777, 242.8005777641172, 242.86534408573425, 242.92879522375762, 242.99091288810467, 243.05167918668593, 243.1110766296677, 243.16908813362656, 243.22569702559343, 243.2808870469891, 243.33464235744924, 243.3869475385389, 243.43778759736006, 243.48714797004627, 243.53501452514953, 243.58137356691998, 243.62621183846994, 243.66951652483468, 243.71127525592078, 243.75147610934607, 243.79010761317204, 243.827158748523, 243.86261895209924, 243.89647811858404, 243.9287266029343, 243.95935522257054, 243.98835525945367, 244.0157184620534, 244.0414370472101, 244.06550370188742, 244.087911584816, 244.10865432803112, 244.12772603829856, 244.14512129843592, 244.16083516852575, 244.1748631870164, 244.18720137172255, 244.19784622071015, 244.20679471308003, 244.21404430963898, 244.21959295346625, 244.2234390703717, 244.22558156924575, 244.22601984230246, 244.22475376521348, 244.22178369713774, 244.21711048063958, 244.21073544150136]
, x_t1=[5286, 887, 0], occupancy_map=occupancy_map)'''
    #print(x)
'''   
    x = sensor1.beam_range_finder_model([66, 66, 66, 66, 66, 65, 66, 66, 65, 66, 66, 66, 66, 66, 67, 67, 67, 66, 67, 66, 67, 67, 67, 68, 68, 68,
                                          69, 67, 530, 514, 506, 508, 494, 481, 470, 458, 445, 420, 410, 402, 393, 386, 379, 371, 365, 363,
                                            363, 364, 358, 353, 349, 344, 339, 335, 332, 328, 324, 321, 304, 299, 298, 294, 291, 288, 287, 284,
                                              282, 281, 277, 277, 276, 274, 273, 271, 269, 268, 267, 266, 265, 265, 264, 263, 263, 263, 262, 261, 261, 261, 261, 261, 193, 190, 189, 189, 192, 262,
                                                262, 264, 194, 191, 190, 190, 193, 269, 271, 272, 274, 275, 277, 279, 279, 281, 283, 285, 288, 289, 292, 295, 298, 300, 303, 306, 309, 314, 318, 321, 325, 329, 335, 340, 360, 366,
                                                  372, 378, 384, 92, 92, 91, 89, 88, 87, 86, 85, 84, 83, 82, 82, 81, 81, 80, 79, 78, 78, 77, 76, 76, 76, 75, 75, 74, 74, 73, 73, 72, 72, 72, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 70, 70, 70, 70], x_t1=[4892, 916, 0.523599], occupancy_map=occupancy_map)
    #print(x)

    SensorModel.beam_range_finder_model([66, 66, 66, 66, 66, 65, 66, 66, 65, 66, 66, 66, 66, 66, 67, 67, 67, 66, 67, 66, 67, 67, 67, 68, 68, 68,
                                          69, 67, 530, 514, 506, 508, 494, 481, 470, 458, 445, 420, 410, 402, 393, 386, 379, 371, 365, 363,
                                            363, 364, 358, 353, 349, 344, 339, 335, 332, 328, 324, 321, 304, 299, 298, 294, 291, 288, 287, 284,
                                              282, 281, 277, 277, 276, 274, 273, 271, 269, 268, 267, 266, 265, 265, 264, 263, 263, 263, 262, 261, 261, 261, 261, 261, 193, 190, 189, 189, 192, 262,
                                                262, 264, 194, 191, 190, 190, 193, 269, 271, 272, 274, 275, 277, 279, 279, 281, 283, 285, 288, 289, 292, 295, 298, 300, 303, 306, 309, 314, 318, 321, 325, 329, 335, 340, 360, 366,
                                                  372, 378, 384, 92, 92, 91, 89, 88, 87, 86, 85, 84, 83, 82, 82, 81, 81, 80, 79, 78, 78, 77, 76, 76, 76, 75, 75, 74, 74, 73, 73, 72, 72, 72, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 70, 70, 70, 70])
'''
